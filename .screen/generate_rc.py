#!/usr/bin/env python

# The problem:
# I use screen quite a bit. Often, my usage pattern is this:
# 1. start screen
# 2. go to some folder and start vim
# 3. create another screen window
# 4. either use the new window as another vim instance (step 2)
#    or use it as a terminal (end)
#
# I prefer screen over windows/tabs as it groups related things together,
# and I find Control-A Control-A is easier and faster than Alt-Tab / Win-Tab
#
# So:
# Since I'm lazy, I essentially create a screen session session config file
# that creates the windows and goes to the respective directories.
#
# Copy paste is boring, so this python script generates the config file for me
# from a simple input file.
#
# See example.conf for an example input file.
# Starting the screen session is done using sstart.sh which just calls screen
# with the config file. Note that no arguments are passed to screen (TODO).
#
# Files:
# .screenrc - your screenrc file (this is sourced)
# .screen/ - directory to keep stuff
# .screen/generate_rc.py - this file
# .screen/example.conf - example input file
# .screen/example.rc - generated example config file
# bin/sstart.sh - basic script to call screen with config file

# NOTE: NO ERROR CHECKING ON THE FILE IS DONE!
# THE FILE WILL BE INTERPRETTED AS SUCH

ENV_ROOT_DIR = 'CURRENT_SCREEN_ROOT'

def process_line(line, outfile):
    line = line.strip()
    if not line or line.startswith('#'): # blank or comment
        return

    # get the line and parse into [[title]:]directory
    title = ''
    directory = ''
    colon_pos = line.find(':')
    if colon_pos > -1:
        title = line[:colon_pos].strip()
        directory = line[colon_pos+1:].strip()
    else:
        directory = line

    # always have a leading slash
    if not directory.startswith('/'):
        directory = '/' + directory

    # if no title, use the last directory name as title
    if title == '':
        title = line[line.rfind('/')+1:]

    # write out the commands now
    outfile.write("chdir ${%s}%s\n" %(ENV_ROOT_DIR, directory))
    outfile.write("screen -t '%s'\n" %title)
    outfile.write("exec ls --color\n")
    outfile.write("\n")
    # print "%s : %s" %(title, directory)


if __name__ == '__main__':
    import sys
    if len(sys.argv) < 2:
        print "generate_rc.py [CONF_FILES]"

    infile = None
    rcfile = ''
    outfile = None
    for conf in sys.argv[1:]:
        rcfile = conf
        # if file ends in .conf, replace with .rc
        # else just append .rc
        if conf.endswith('.conf'):
            rcfile = conf[:-5]
        rcfile += '.rc'

        print "Generating: %s" %rcfile
        try:
            infile = open(conf, 'r')
            outfile = open(rcfile, 'w')
        except:
            print 'Error opening files: "%s" "%s"' %(conf, rcfile)
            continue

        root = ''
        while not root or root.startswith('#'):
            root = infile.readline().strip()

        # header
        line = "# AUTOGENERATED FROM: %s #" %conf
        outfile.write("#" * len(line) + "\n")
        outfile.write("%s\n" %line)
        outfile.write("#" * len(line) + "\n\n")
        outfile.write("source ${HOME}/.screenrc\n\n")
        outfile.write("setenv %s %s\n\n" %(ENV_ROOT_DIR, root))

        # body
        line = infile.readline()
        while line:
            process_line(line, outfile)
            line = infile.readline()

        # footer
        outfile.write("select 0\n\n")
        outfile.write("chdir ${%s}\n" %ENV_ROOT_DIR)
        outfile.write("unsetenv %s\n" %ENV_ROOT_DIR)

        # cleanup
        infile.close()
        outfile.close()

